{"ast":null,"code":"import { useRef, useState } from 'react';\nimport useMouseEvents from './useMouseEvents';\nimport useTouchEvents from './useTouchEvents';\nimport { getDirection, getHorizontalDirection, getPointerCoordinates, getVerticalDirection } from './shared/swipeUtils';\nconst defaultOptions = {\n  direction: 'both',\n  threshold: 10,\n  preventDefault: true\n};\nconst initialState = {\n  swiping: false,\n  direction: undefined,\n  alphaX: 0,\n  alphaY: 0,\n  count: 0\n};\nconst isEqual = (prev, next) => prev.swiping === next.swiping && prev.direction === next.direction && prev.count === next.count && prev.alphaX === next.alphaX && prev.alphaY === next.alphaY;\n/**\n * useSwipe hook\n */\nconst useSwipe = (targetRef = null, options = defaultOptions) => {\n  const [state, setState] = useState(initialState);\n  const startingPointRef = useRef([-1, -1]);\n  const isDraggingRef = useRef(false);\n  const opts = Object.assign(Object.assign({}, defaultOptions), options || {});\n  const {\n    onMouseDown,\n    onMouseMove,\n    onMouseLeave,\n    onMouseUp\n  } = useMouseEvents(targetRef);\n  const {\n    onTouchStart,\n    onTouchMove,\n    onTouchEnd,\n    onTouchCancel\n  } = useTouchEvents(targetRef);\n  const startSwipe = event => {\n    const [clientX, clientY] = getPointerCoordinates(event);\n    startingPointRef.current = [clientX, clientY];\n    if (opts.preventDefault) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n  };\n  const continueSwipe = event => {\n    const [clientX, clientY] = getPointerCoordinates(event);\n    if (opts.preventDefault) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n    if (isDraggingRef.current || startingPointRef.current[0] !== -1 && startingPointRef.current[1] !== -1) {\n      const alpha = [startingPointRef.current[0] - clientX, startingPointRef.current[1] - clientY];\n      if (opts.direction === 'both' && (Math.abs(alpha[0]) > opts.threshold || Math.abs(alpha[1]) > opts.threshold)) {\n        isDraggingRef.current = true;\n        const nextState = {\n          alphaX: alpha[0],\n          alphaY: alpha[1],\n          count: state.count,\n          swiping: true,\n          direction: getDirection([clientX, clientY], startingPointRef.current, alpha)\n        };\n        if (!isEqual(nextState, state)) {\n          setState(nextState);\n        }\n      }\n      if (opts.direction === 'horizontal' && Math.abs(alpha[0]) > opts.threshold) {\n        isDraggingRef.current = true;\n        const nextState = {\n          alphaX: alpha[0],\n          alphaY: 0,\n          count: state.count,\n          swiping: true,\n          direction: getHorizontalDirection(alpha[0])\n        };\n        if (!isEqual(nextState, state)) {\n          setState(nextState);\n        }\n      }\n      if (opts.direction === 'vertical' && Math.abs(alpha[1]) > opts.threshold) {\n        isDraggingRef.current = true;\n        const nextState = {\n          alphaY: alpha[1],\n          alphaX: 0,\n          count: state.count,\n          swiping: true,\n          direction: getVerticalDirection(alpha[1])\n        };\n        if (!isEqual(nextState, state)) {\n          setState(nextState);\n        }\n      }\n    }\n  };\n  const endSwipe = event => {\n    if (isDraggingRef.current) {\n      if (opts.preventDefault) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n      setState(prevState => Object.assign(Object.assign({}, prevState), {\n        swiping: false,\n        count: state.count + 1\n      }));\n    }\n    startingPointRef.current = [-1, -1];\n    isDraggingRef.current = false;\n  };\n  onMouseDown(startSwipe);\n  onTouchStart(startSwipe);\n  onMouseMove(continueSwipe);\n  onTouchMove(continueSwipe);\n  onMouseUp(endSwipe);\n  onTouchEnd(endSwipe);\n  onMouseLeave(endSwipe);\n  onTouchCancel(endSwipe);\n  return state;\n};\nexport default useSwipe;","map":{"version":3,"names":["useRef","useState","useMouseEvents","useTouchEvents","getDirection","getHorizontalDirection","getPointerCoordinates","getVerticalDirection","defaultOptions","direction","threshold","preventDefault","initialState","swiping","undefined","alphaX","alphaY","count","isEqual","prev","next","useSwipe","targetRef","options","state","setState","startingPointRef","isDraggingRef","opts","Object","assign","onMouseDown","onMouseMove","onMouseLeave","onMouseUp","onTouchStart","onTouchMove","onTouchEnd","onTouchCancel","startSwipe","event","clientX","clientY","current","stopPropagation","continueSwipe","alpha","Math","abs","nextState","endSwipe","prevState"],"sources":["C:/Users/HAI/OneDrive/Documents/Hobby/Frontend/node_modules/beautiful-react-hooks/esm/useSwipe.js"],"sourcesContent":["import { useRef, useState } from 'react';\nimport useMouseEvents from './useMouseEvents';\nimport useTouchEvents from './useTouchEvents';\nimport { getDirection, getHorizontalDirection, getPointerCoordinates, getVerticalDirection } from './shared/swipeUtils';\nconst defaultOptions = {\n    direction: 'both',\n    threshold: 10,\n    preventDefault: true,\n};\nconst initialState = { swiping: false, direction: undefined, alphaX: 0, alphaY: 0, count: 0 };\nconst isEqual = (prev, next) => (prev.swiping === next.swiping\n    && prev.direction === next.direction\n    && prev.count === next.count\n    && prev.alphaX === next.alphaX\n    && prev.alphaY === next.alphaY);\n/**\n * useSwipe hook\n */\nconst useSwipe = (targetRef = null, options = defaultOptions) => {\n    const [state, setState] = useState(initialState);\n    const startingPointRef = useRef([-1, -1]);\n    const isDraggingRef = useRef(false);\n    const opts = Object.assign(Object.assign({}, defaultOptions), (options || {}));\n    const { onMouseDown, onMouseMove, onMouseLeave, onMouseUp } = useMouseEvents(targetRef);\n    const { onTouchStart, onTouchMove, onTouchEnd, onTouchCancel } = useTouchEvents(targetRef);\n    const startSwipe = (event) => {\n        const [clientX, clientY] = getPointerCoordinates(event);\n        startingPointRef.current = [clientX, clientY];\n        if (opts.preventDefault) {\n            event.preventDefault();\n            event.stopPropagation();\n        }\n    };\n    const continueSwipe = (event) => {\n        const [clientX, clientY] = getPointerCoordinates(event);\n        if (opts.preventDefault) {\n            event.preventDefault();\n            event.stopPropagation();\n        }\n        if (isDraggingRef.current || (startingPointRef.current[0] !== -1 && startingPointRef.current[1] !== -1)) {\n            const alpha = [startingPointRef.current[0] - clientX, startingPointRef.current[1] - clientY];\n            if (opts.direction === 'both' && (Math.abs(alpha[0]) > opts.threshold || Math.abs(alpha[1]) > opts.threshold)) {\n                isDraggingRef.current = true;\n                const nextState = {\n                    alphaX: alpha[0],\n                    alphaY: alpha[1],\n                    count: state.count,\n                    swiping: true,\n                    direction: getDirection([clientX, clientY], startingPointRef.current, alpha),\n                };\n                if (!isEqual(nextState, state)) {\n                    setState(nextState);\n                }\n            }\n            if (opts.direction === 'horizontal' && Math.abs(alpha[0]) > opts.threshold) {\n                isDraggingRef.current = true;\n                const nextState = {\n                    alphaX: alpha[0],\n                    alphaY: 0,\n                    count: state.count,\n                    swiping: true,\n                    direction: getHorizontalDirection(alpha[0]),\n                };\n                if (!isEqual(nextState, state)) {\n                    setState(nextState);\n                }\n            }\n            if (opts.direction === 'vertical' && Math.abs(alpha[1]) > opts.threshold) {\n                isDraggingRef.current = true;\n                const nextState = {\n                    alphaY: alpha[1],\n                    alphaX: 0,\n                    count: state.count,\n                    swiping: true,\n                    direction: getVerticalDirection(alpha[1]),\n                };\n                if (!isEqual(nextState, state)) {\n                    setState(nextState);\n                }\n            }\n        }\n    };\n    const endSwipe = (event) => {\n        if (isDraggingRef.current) {\n            if (opts.preventDefault) {\n                event.preventDefault();\n                event.stopPropagation();\n            }\n            setState((prevState) => (Object.assign(Object.assign({}, prevState), { swiping: false, count: state.count + 1 })));\n        }\n        startingPointRef.current = [-1, -1];\n        isDraggingRef.current = false;\n    };\n    onMouseDown(startSwipe);\n    onTouchStart(startSwipe);\n    onMouseMove(continueSwipe);\n    onTouchMove(continueSwipe);\n    onMouseUp(endSwipe);\n    onTouchEnd(endSwipe);\n    onMouseLeave(endSwipe);\n    onTouchCancel(endSwipe);\n    return state;\n};\nexport default useSwipe;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}