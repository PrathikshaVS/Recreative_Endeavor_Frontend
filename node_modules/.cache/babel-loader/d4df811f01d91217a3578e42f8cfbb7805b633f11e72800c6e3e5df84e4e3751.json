{"ast":null,"code":"import useHandlerSetterRef from './shared/useHandlerSetterRef';\nimport createCbSetterErrorProxy from './shared/createCbSetterErrorProxy';\nimport safeHasOwnProperty from './shared/safeHasOwnProperty';\nimport assignEventOnMount from './shared/assignEventOnMount';\n/**\n * Returns a frozen object of callback setters to handle the touch events.<br/>\n * It accepts a DOM ref representing the events target. <br/>\n * If a target is not provided the events will be globally attached to the document object.\n * <br/>\n * ### Shall the `useTouchEvents` callbacks replace the standard mouse handler props?\n *\n * **They shall not!**<br />\n * **useTouchEvents is meant to be used to abstract more complex hooks that need to control mouse**, for instance:\n * a drag n drop hook.<br />\n * Using useTouchEvents handlers instead of the classic props approach it's just as bad as it sounds since you'll\n * lose the React SyntheticEvent performance boost.<br />\n * If you were doing something like the following:\n *\n */\nconst useTouchEvents = (targetRef = null) => {\n  const [onTouchStartHandler, setOnTouchStartHandler] = useHandlerSetterRef();\n  const [onTouchEndHandler, setOnTouchEndHandler] = useHandlerSetterRef();\n  const [onTouchCancelHandler, setOnTouchCancelHandler] = useHandlerSetterRef();\n  const [onTouchMoveHandler, setOnTouchMoveHandler] = useHandlerSetterRef();\n  if (targetRef !== null && !safeHasOwnProperty(targetRef, 'current')) {\n    return createCbSetterErrorProxy('Unable to assign any touch event to the given ref');\n  }\n  assignEventOnMount(targetRef, onTouchStartHandler, 'touchstart');\n  assignEventOnMount(targetRef, onTouchEndHandler, 'touchend');\n  assignEventOnMount(targetRef, onTouchCancelHandler, 'touchcancel');\n  assignEventOnMount(targetRef, onTouchMoveHandler, 'touchmove');\n  return Object.freeze({\n    onTouchStart: setOnTouchStartHandler,\n    onTouchEnd: setOnTouchEndHandler,\n    onTouchCancel: setOnTouchCancelHandler,\n    onTouchMove: setOnTouchMoveHandler\n  });\n};\nexport default useTouchEvents;","map":{"version":3,"names":["useHandlerSetterRef","createCbSetterErrorProxy","safeHasOwnProperty","assignEventOnMount","useTouchEvents","targetRef","onTouchStartHandler","setOnTouchStartHandler","onTouchEndHandler","setOnTouchEndHandler","onTouchCancelHandler","setOnTouchCancelHandler","onTouchMoveHandler","setOnTouchMoveHandler","Object","freeze","onTouchStart","onTouchEnd","onTouchCancel","onTouchMove"],"sources":["C:/Users/HAI/OneDrive/Documents/Frontend/node_modules/beautiful-react-hooks/esm/useTouchEvents.js"],"sourcesContent":["import useHandlerSetterRef from './shared/useHandlerSetterRef';\nimport createCbSetterErrorProxy from './shared/createCbSetterErrorProxy';\nimport safeHasOwnProperty from './shared/safeHasOwnProperty';\nimport assignEventOnMount from './shared/assignEventOnMount';\n/**\n * Returns a frozen object of callback setters to handle the touch events.<br/>\n * It accepts a DOM ref representing the events target. <br/>\n * If a target is not provided the events will be globally attached to the document object.\n * <br/>\n * ### Shall the `useTouchEvents` callbacks replace the standard mouse handler props?\n *\n * **They shall not!**<br />\n * **useTouchEvents is meant to be used to abstract more complex hooks that need to control mouse**, for instance:\n * a drag n drop hook.<br />\n * Using useTouchEvents handlers instead of the classic props approach it's just as bad as it sounds since you'll\n * lose the React SyntheticEvent performance boost.<br />\n * If you were doing something like the following:\n *\n */\nconst useTouchEvents = (targetRef = null) => {\n    const [onTouchStartHandler, setOnTouchStartHandler] = useHandlerSetterRef();\n    const [onTouchEndHandler, setOnTouchEndHandler] = useHandlerSetterRef();\n    const [onTouchCancelHandler, setOnTouchCancelHandler] = useHandlerSetterRef();\n    const [onTouchMoveHandler, setOnTouchMoveHandler] = useHandlerSetterRef();\n    if (targetRef !== null && !safeHasOwnProperty(targetRef, 'current')) {\n        return createCbSetterErrorProxy('Unable to assign any touch event to the given ref');\n    }\n    assignEventOnMount(targetRef, onTouchStartHandler, 'touchstart');\n    assignEventOnMount(targetRef, onTouchEndHandler, 'touchend');\n    assignEventOnMount(targetRef, onTouchCancelHandler, 'touchcancel');\n    assignEventOnMount(targetRef, onTouchMoveHandler, 'touchmove');\n    return Object.freeze({\n        onTouchStart: setOnTouchStartHandler,\n        onTouchEnd: setOnTouchEndHandler,\n        onTouchCancel: setOnTouchCancelHandler,\n        onTouchMove: setOnTouchMoveHandler,\n    });\n};\nexport default useTouchEvents;\n"],"mappings":"AAAA,OAAOA,mBAAmB,MAAM,8BAA8B;AAC9D,OAAOC,wBAAwB,MAAM,mCAAmC;AACxE,OAAOC,kBAAkB,MAAM,6BAA6B;AAC5D,OAAOC,kBAAkB,MAAM,6BAA6B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,cAAc,GAAGA,CAACC,SAAS,GAAG,IAAI,KAAK;EACzC,MAAM,CAACC,mBAAmB,EAAEC,sBAAsB,CAAC,GAAGP,mBAAmB,CAAC,CAAC;EAC3E,MAAM,CAACQ,iBAAiB,EAAEC,oBAAoB,CAAC,GAAGT,mBAAmB,CAAC,CAAC;EACvE,MAAM,CAACU,oBAAoB,EAAEC,uBAAuB,CAAC,GAAGX,mBAAmB,CAAC,CAAC;EAC7E,MAAM,CAACY,kBAAkB,EAAEC,qBAAqB,CAAC,GAAGb,mBAAmB,CAAC,CAAC;EACzE,IAAIK,SAAS,KAAK,IAAI,IAAI,CAACH,kBAAkB,CAACG,SAAS,EAAE,SAAS,CAAC,EAAE;IACjE,OAAOJ,wBAAwB,CAAC,mDAAmD,CAAC;EACxF;EACAE,kBAAkB,CAACE,SAAS,EAAEC,mBAAmB,EAAE,YAAY,CAAC;EAChEH,kBAAkB,CAACE,SAAS,EAAEG,iBAAiB,EAAE,UAAU,CAAC;EAC5DL,kBAAkB,CAACE,SAAS,EAAEK,oBAAoB,EAAE,aAAa,CAAC;EAClEP,kBAAkB,CAACE,SAAS,EAAEO,kBAAkB,EAAE,WAAW,CAAC;EAC9D,OAAOE,MAAM,CAACC,MAAM,CAAC;IACjBC,YAAY,EAAET,sBAAsB;IACpCU,UAAU,EAAER,oBAAoB;IAChCS,aAAa,EAAEP,uBAAuB;IACtCQ,WAAW,EAAEN;EACjB,CAAC,CAAC;AACN,CAAC;AACD,eAAeT,cAAc"},"metadata":{},"sourceType":"module","externalDependencies":[]}