{"ast":null,"code":"import { useCallback, useEffect, useRef, useState } from 'react';\nimport usePreviousValue from './usePreviousValue';\nconst defaultOptions = {\n  cancelOnUnmount: true,\n  cancelOnConditionChange: true\n};\n/**\n * An async-utility hook that accepts a callback function and a delay time (in milliseconds), then delays the\n * execution of the given function by the defined time from when the condition verifies.\n */\nconst useConditionalTimeout = (fn, milliseconds, condition, options = defaultOptions) => {\n  const opts = Object.assign(Object.assign({}, defaultOptions), options || {});\n  const timeout = useRef();\n  const callback = useRef(fn);\n  const [isCleared, setIsCleared] = useState(false);\n  const prevCondition = usePreviousValue(condition);\n  // the clear method\n  const clear = useCallback(() => {\n    if (timeout.current) {\n      clearTimeout(timeout.current);\n      setIsCleared(true);\n    }\n  }, []);\n  // if the provided function changes, change its reference\n  useEffect(() => {\n    if (typeof fn === 'function') {\n      callback.current = fn;\n    }\n  }, [fn]);\n  // when the milliseconds change, reset the timeout\n  useEffect(() => {\n    if (condition && typeof milliseconds === 'number') {\n      timeout.current = setTimeout(() => {\n        callback.current();\n      }, milliseconds);\n    }\n  }, [condition, milliseconds]);\n  // when the condition change, clear the timeout\n  useEffect(() => {\n    if (prevCondition && condition !== prevCondition && opts.cancelOnConditionChange) {\n      clear();\n    }\n  }, [condition, options]);\n  // when component unmount clear the timeout\n  useEffect(() => () => {\n    if (opts.cancelOnUnmount) {\n      clear();\n    }\n  }, []);\n  return [isCleared, clear];\n};\nexport default useConditionalTimeout;","map":{"version":3,"names":["useCallback","useEffect","useRef","useState","usePreviousValue","defaultOptions","cancelOnUnmount","cancelOnConditionChange","useConditionalTimeout","fn","milliseconds","condition","options","opts","Object","assign","timeout","callback","isCleared","setIsCleared","prevCondition","clear","current","clearTimeout","setTimeout"],"sources":["C:/Users/HAI/OneDrive/Documents/Hobby/Frontend/node_modules/beautiful-react-hooks/esm/useConditionalTimeout.js"],"sourcesContent":["import { useCallback, useEffect, useRef, useState } from 'react';\nimport usePreviousValue from './usePreviousValue';\nconst defaultOptions = {\n    cancelOnUnmount: true,\n    cancelOnConditionChange: true,\n};\n/**\n * An async-utility hook that accepts a callback function and a delay time (in milliseconds), then delays the\n * execution of the given function by the defined time from when the condition verifies.\n */\nconst useConditionalTimeout = (fn, milliseconds, condition, options = defaultOptions) => {\n    const opts = Object.assign(Object.assign({}, defaultOptions), (options || {}));\n    const timeout = useRef();\n    const callback = useRef(fn);\n    const [isCleared, setIsCleared] = useState(false);\n    const prevCondition = usePreviousValue(condition);\n    // the clear method\n    const clear = useCallback(() => {\n        if (timeout.current) {\n            clearTimeout(timeout.current);\n            setIsCleared(true);\n        }\n    }, []);\n    // if the provided function changes, change its reference\n    useEffect(() => {\n        if (typeof fn === 'function') {\n            callback.current = fn;\n        }\n    }, [fn]);\n    // when the milliseconds change, reset the timeout\n    useEffect(() => {\n        if (condition && typeof milliseconds === 'number') {\n            timeout.current = setTimeout(() => {\n                callback.current();\n            }, milliseconds);\n        }\n    }, [condition, milliseconds]);\n    // when the condition change, clear the timeout\n    useEffect(() => {\n        if (prevCondition && condition !== prevCondition && opts.cancelOnConditionChange) {\n            clear();\n        }\n    }, [condition, options]);\n    // when component unmount clear the timeout\n    useEffect(() => () => {\n        if (opts.cancelOnUnmount) {\n            clear();\n        }\n    }, []);\n    return [isCleared, clear];\n};\nexport default useConditionalTimeout;\n"],"mappings":"AAAA,SAASA,WAAW,EAAEC,SAAS,EAAEC,MAAM,EAAEC,QAAQ,QAAQ,OAAO;AAChE,OAAOC,gBAAgB,MAAM,oBAAoB;AACjD,MAAMC,cAAc,GAAG;EACnBC,eAAe,EAAE,IAAI;EACrBC,uBAAuB,EAAE;AAC7B,CAAC;AACD;AACA;AACA;AACA;AACA,MAAMC,qBAAqB,GAAGA,CAACC,EAAE,EAAEC,YAAY,EAAEC,SAAS,EAAEC,OAAO,GAAGP,cAAc,KAAK;EACrF,MAAMQ,IAAI,GAAGC,MAAM,CAACC,MAAM,CAACD,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEV,cAAc,CAAC,EAAGO,OAAO,IAAI,CAAC,CAAE,CAAC;EAC9E,MAAMI,OAAO,GAAGd,MAAM,CAAC,CAAC;EACxB,MAAMe,QAAQ,GAAGf,MAAM,CAACO,EAAE,CAAC;EAC3B,MAAM,CAACS,SAAS,EAAEC,YAAY,CAAC,GAAGhB,QAAQ,CAAC,KAAK,CAAC;EACjD,MAAMiB,aAAa,GAAGhB,gBAAgB,CAACO,SAAS,CAAC;EACjD;EACA,MAAMU,KAAK,GAAGrB,WAAW,CAAC,MAAM;IAC5B,IAAIgB,OAAO,CAACM,OAAO,EAAE;MACjBC,YAAY,CAACP,OAAO,CAACM,OAAO,CAAC;MAC7BH,YAAY,CAAC,IAAI,CAAC;IACtB;EACJ,CAAC,EAAE,EAAE,CAAC;EACN;EACAlB,SAAS,CAAC,MAAM;IACZ,IAAI,OAAOQ,EAAE,KAAK,UAAU,EAAE;MAC1BQ,QAAQ,CAACK,OAAO,GAAGb,EAAE;IACzB;EACJ,CAAC,EAAE,CAACA,EAAE,CAAC,CAAC;EACR;EACAR,SAAS,CAAC,MAAM;IACZ,IAAIU,SAAS,IAAI,OAAOD,YAAY,KAAK,QAAQ,EAAE;MAC/CM,OAAO,CAACM,OAAO,GAAGE,UAAU,CAAC,MAAM;QAC/BP,QAAQ,CAACK,OAAO,CAAC,CAAC;MACtB,CAAC,EAAEZ,YAAY,CAAC;IACpB;EACJ,CAAC,EAAE,CAACC,SAAS,EAAED,YAAY,CAAC,CAAC;EAC7B;EACAT,SAAS,CAAC,MAAM;IACZ,IAAImB,aAAa,IAAIT,SAAS,KAAKS,aAAa,IAAIP,IAAI,CAACN,uBAAuB,EAAE;MAC9Ec,KAAK,CAAC,CAAC;IACX;EACJ,CAAC,EAAE,CAACV,SAAS,EAAEC,OAAO,CAAC,CAAC;EACxB;EACAX,SAAS,CAAC,MAAM,MAAM;IAClB,IAAIY,IAAI,CAACP,eAAe,EAAE;MACtBe,KAAK,CAAC,CAAC;IACX;EACJ,CAAC,EAAE,EAAE,CAAC;EACN,OAAO,CAACH,SAAS,EAAEG,KAAK,CAAC;AAC7B,CAAC;AACD,eAAeb,qBAAqB"},"metadata":{},"sourceType":"module","externalDependencies":[]}